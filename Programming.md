# **Программирование**
___

*Содержание*

1. [Структуры данных](#структуры-данных)
	1. [Массивы](#массивы)
	0. [Связные списки](#связные-списки)
	0. [Стек и очередь](#стек-и-очередь)
0. [Объектно-ориентированное программирование](#объектно-ориентированное-программирование)
	1. [Основные принципы ООП](#основные-принципы-ООП)
	0. [SOLID](#solid)
	0. [Шаблоны проектирования](#шаблоны-проектирования)

# Структуры данных

## **Массивы**

* Упорядоченный набор данных. 
* Данные в массиве одного типа (размера).
* Нумерация массива начинается с нуля.
* Индекс - целое число.

✅ **Плюсы**
 * Легкое вычисление адреса элемента по индексу.
 * Одинаковое время доступа ко всем элементам.
 * Структура состоит только из информационных полей.

❗ **Минусы**
* Динамика удаления и добавления затруднена, необходимы сдвиги элементов.
* Угроза выхода за границы массива при работе с указателями.

**Применение**

> Применяется для хранения большого объема данных с последующим добавлением новых.

## **Связные списки**

* Состоит из серии узлов.	
* Данные списка содержат ссылки на следующий элемент и/или предыдущий элемент.

*Бывают односвязные, двусвязный и циклические (кольцевые) списки.*

✅ **Плюсы**

* Добавление и удаление объектов главный плюс.
* Могут хранится разные типы данных. 

❗ **Минусы**

* Медленный доступ к произвольному n-ому элементу.

**Применение**

> Используются для часто изменяющих связных данных.

## **Стек и очередь**

Это коллекции элементов у которых реализованы интерфейсы по принципу:
* Last-In-First-Out или LIFO для стека
* First-In-First-Out или FIFO для очереди

Основные методы:

* Добавить элемент
* Получить элеменет

**Применение**

> Стек применяется:
* передачи и возвращения параметров при вызовах процедур;
* хранение состояний патерна Memento;
* в цепочке поручений.

> Очередь применяется:
* когда нужно совершить какие-то действия в порядке их поступления, выполнив их последовательно;
* обработка данных из нескольких потоков.

# Объектно-ориентированное программирование

## Основные принципы ООП

* Абстракция — отделение концепции от ее экземпляра.
* Полиморфизм — реализация задач одной и той же идеи разными способами.
* Наследование — способность объекта или класса базироваться на другом объекте или классе.
* Инкапсуляция — размещение одного объекта или класса внутри другого для разграничения доступа к ним.

## SOLID

> Принцип единственной обязанности *single responsibility*
* У модуля должна быть только одна причина для изменения, класс должен отвечает за что-то одно. 
* При правках необходимо задействовать минимальное кол-во классов, уменьшая межмодульную зависимость. 

> Принцип открытости/закрытости *open-closed*
* Модуль должен быть открыт для расширения, но закрыты для изменений. 
* Идея разработки устойчивого к изменениям приложения.
* Правки одного класса не должны затрагивать много связанных с ним модулей. 
* Нужно больше абстракции для расширения, что бы не вносить правки в базовый класс.


> Принцип подстановки Барбары Лисков *Liskov substitution*
* Подклассы могут заменять свои суперклассы.
* Классы наследники должны заменять своих родителей, без нарушения основной логики.
* Необходимо использовать общий интерфейс, а не наследование, делать поведение модулей предсказуемым.
* Вводить запреты на наследования, что бы потомки не противоречили базовому поведению. 

> Принцип разделения интерфейсов *interface segregation*
* Сущности не должны завесить от интерфейсов, которые они используют.
* Больше декомпозировать интерфейсы на более мелкие тематики.
* Идея снижение зависимостей между модулями.
* При воплощении интерфейса нет не нужной функциональности которую нужно реализовывать.
* При внесении изменений затрагиваются только нужные части модуля, а не все классы.

> Принцип инверсии зависимостей *dependency inversion*
* Модули высших уровней не должный завесить от модулей низких уровней, оба должны зависеть от абстракции.
* Абстракции не должны зависеть от деталей, детали зависят от абстракций.
* Верхнеуровневые сущности не должный зависеть от нижнеуровневых реализаций.
* Зависимости нужно выносить в абстракции и инкапсулировать в отдельную сущность. 
* Уменьшение межмодульной зависимости.

## Шаблоны проектирования

Шаблоны (паттерн) проектирования — это правило проектирования архитектуры при решении конкретной проблемы.

* Паттерн не шаблонный код, а концепция, которую нужно подстроить под задачи.
* Паттерн не алгоритм, алгоритм — это чёткий набор действий (рецепт), паттерн — это высокоуровневое описание решения (чертёж), которое может отличаться при реализации.

Применение паттернов дает проверенные решения, стандартизацию кода и намерения одно программиста сразу понятны другим.

Классификация:
Низкоуровневые и простые паттерны (идиомы), не универсальны, поскольку применимы только в рамках одного языка программирования.
Универсальные — архитектурные паттерны, для проектирования всей программы.

Выделяют основных 23 паттерна из книни "GoF book", которые делятся на 3 группы:
* Порождающие (creational):
	1.  Фабричный метод (Factory Method) 
	> определяет общий интерфейс для создания объектов в суперклассе, позволяя подклассам изменять тип создаваемых объектов.

	2.  Абстрактная фабрика (Abstract Factory) 
	> позволяет создавать семейства связанных объектов, не привязываясь к конкретным классам создаваемых объектов.

	3.  Строитель (Builder) 
	> класс Строитель отдает конструктор Директору(ам),а они строют разные представления объекта.

	4.  Прототип (Prototype) 
	> позволяет копировать объекты, не вдаваясь в подробности их реализации. У класса есть метод copy(), который копирут сокрытые данные тоже.

	5.  Одиночка (Singleton, monostate) 
	> гарантирует, что у класса есть только один экземпляр, и предоставляет к нему глобальную точку доступа.
	
* Структурные (structural):
	1.  Адаптер (Adapter)
	> позволяет объектам с несовместимыми интерфейсами работать вместе.

	2.  Мост (Bridge)
    > разделяет класс — абстракцию и реализацию, позволяя изменять их независимо друг от друга.
	
	3.  Компоновщик (Composite)
	> группировка множества объектов в древовидную структуру, далее работать с ней как с одинм объектом.
	
	4.  Декоратор (Decorator)
	> добавлять объектам новую функциональность, оборачивая их.
	
	5.  Фасад (Facade)
	> предоставляет простой интерфейс к сложной системе.
	
	6.  Легковес (Flyweight)
	> хранение отдельно одинаковых данных объектов.
	
	7.  Заместитель (Proxy)
	> В основном кеширования результатов сложных операций. 
	
* Поведенческие (behavioral):
	1.  Цепочка обязанностей (Chain of Responsibility)
	> передача запросов по цепочке обработчиков. Обрабочик решает: передать дальше или нет.
	
	2.  Команда (Command)
	>
	
	3.  Итератор (Iterator)
	>
	
	4.  Посредник (Mediator)
	>
	
	5.  Снимок (Memento)
	>
	
	6.  Наблюдатель (Observer)
	>
	
	7.  Состояние (State)
	>
	
	8.  Стратегия (Strategy)
	>
	
	9.  Шаблонный метод (Template Method)
	>
	
	10.  Посетитель (Visitor)
	>
	
